# üéØ Guide √âtape par √âtape - Agent Intelligent avec Semantic Kernel

## üìö Vue d'Ensemble du Projet

Ce guide vous accompagne dans la construction d'un **agent intelligent avec m√©moire** en utilisant Semantic Kernel. Vous apprendrez en faisant - chaque √©tape vous enseigne des concepts cl√©s tout en construisant un assistant personnel avec planification automatique.

### üéØ Objectifs d'Apprentissage
- Ma√Ætriser les concepts Semantic Kernel
- Cr√©er et int√©grer des plugins personnalis√©s
- Impl√©menter une m√©moire persistante
- Utiliser la planification automatique
- Construire un assistant adaptatif

## üöÄ D√©marrage Rapide

```bash
# 1. Installer les d√©pendances
pip install semantic-kernel openai python-dotenv

# 2. Configurer votre cl√© API
cp .env.example .env
# Ajouter votre OPENAI_API_KEY dans le fichier .env

# 3. Lancer le projet starter
python my_intelligent_agent_starter.py
```

## üìã Progression √âtape par √âtape

### ‚úÖ TODO 1: Installation des D√©pendances (2 min)

**Concepts appris**: √âcosyst√®me Semantic Kernel et architecture Microsoft

```bash
pip install semantic-kernel openai python-dotenv
```

**Pourquoi ces packages ?**
- `semantic-kernel`: Framework principal Microsoft pour agents IA
- `openai`: Int√©gration OpenAI (GPT-4) pour les fonctions s√©mantiques
- `python-dotenv`: Gestion s√©curis√©e des configurations

### ‚úÖ TODO 2: Imports et Architecture (3 min)

**Concepts appris**: Structure modulaire de Semantic Kernel

D√©commentez et compl√©tez les imports dans `my_intelligent_agent_starter.py`:

```python
import semantic_kernel as sk
from semantic_kernel.connectors.ai.open_ai import OpenAIChatCompletion
from semantic_kernel.planning import BasicPlanner
from semantic_kernel.memory import SemanticTextMemory
from semantic_kernel.connectors.ai.open_ai import OpenAITextEmbedding
```

**Architecture Semantic Kernel**:
- **Kernel**: Orchestrateur central du syst√®me
- **Functions**: Fonctions natives et s√©mantiques
- **Plugins**: Collections de fonctions r√©utilisables
- **Planner**: Orchestration automatique multi-√©tapes
- **Memory**: Stockage s√©mantique persistant

### ‚úÖ TODO 3: √âtat de l'Agent (5 min)

**Concepts appris**: M√©moire et pr√©f√©rences utilisateur

D√©finissez la classe `AgentState`:

```python
@dataclass
class AgentState:
    """√âtat persistant de l'agent intelligent"""
    created_at: str
    last_interaction: Optional[str]
    user_name: Optional[str]
    communication_style: str = "professional"  # professional/casual/formal
    notification_time: str = "09:00"           # Heure pr√©f√©r√©e
    task_priority: str = "high"                # high/medium/low
    language: str = "fr"                       # Langue pr√©f√©r√©e
    timezone: str = "Europe/Paris"             # Fuseau horaire
    interests: List[str] = None                # Centres d'int√©r√™t
    work_context: Optional[str] = None         # Contexte professionnel
    learning_preferences: List[str] = None     # Style d'apprentissage
    conversation_count: int = 0                # Nombre de conversations
    
    def __post_init__(self):
        if self.interests is None:
            self.interests = []
        if self.learning_preferences is None:
            self.learning_preferences = ["visual", "practical"]
```

**Pourquoi cet √âtat ?**
- **Personnalisation**: Adaptation aux pr√©f√©rences utilisateur
- **Persistance**: M√©moire entre sessions
- **Contextualisation**: R√©ponses adapt√©es au profil
- **√âvolution**: Apprentissage continu des habitudes

### ‚úÖ TODO 4: Syst√®me de Plugins (8 min)

**Concepts appris**: Extensibilit√© avec plugins Semantic Kernel

Compl√©tez la classe `PluginRegistry`:

```python
class PluginRegistry:
    """Registre de plugins personnalis√©s"""
    
    def __init__(self):
        self.plugins = {}
    
    def create_time_plugin(self):
        """Plugin pour gestion du temps"""
        
        @sk_function(
            description="Get the current date and time",
            name="get_current_time"
        )
        def get_current_time() -> str:
            """Obtenir la date et heure actuelles"""
            from datetime import datetime
            return datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        @sk_function(
            description="Calculate time difference between two dates",
            name="calculate_time_diff"
        )
        def calculate_time_diff(date1: str, date2: str) -> str:
            """Calculer la diff√©rence entre deux dates"""
            try:
                from datetime import datetime
                d1 = datetime.strptime(date1, "%Y-%m-%d %H:%M:%S")
                d2 = datetime.strptime(date2, "%Y-%m-%d %H:%M:%S")
                diff = abs((d2 - d1).total_seconds())
                
                hours = int(diff // 3600)
                minutes = int((diff % 3600) // 60)
                return f"{hours}h {minutes}m"
            except Exception as e:
                return f"Erreur de calcul: {e}"
        
        @sk_function(
            description="Schedule a reminder for a specific time",
            name="schedule_reminder"
        )
        def schedule_reminder(message: str, time: str) -> str:
            """Programmer un rappel"""
            # En production: int√©gration avec syst√®me de notifications
            return f"Rappel programm√©: '{message}' √† {time}"
        
        return {
            "get_current_time": get_current_time,
            "calculate_time_diff": calculate_time_diff,
            "schedule_reminder": schedule_reminder
        }
    
    def create_preference_plugin(self):
        """Plugin pour gestion des pr√©f√©rences"""
        
        @sk_function(
            description="Update user preference for a specific setting",
            name="update_preference"
        )
        def update_preference(preference_type: str, value: str) -> str:
            """Mettre √† jour une pr√©f√©rence utilisateur"""
            valid_prefs = [
                "communication_style", "notification_time", 
                "task_priority", "language", "timezone"
            ]
            
            if preference_type in valid_prefs:
                # En production: sauvegarder dans la m√©moire persistante
                return f"Pr√©f√©rence '{preference_type}' mise √† jour: {value}"
            else:
                return f"Type de pr√©f√©rence invalide. Valides: {', '.join(valid_prefs)}"
        
        @sk_function(
            description="Get current user preferences",
            name="get_preferences"
        )
        def get_preferences() -> str:
            """Obtenir les pr√©f√©rences actuelles"""
            # En production: charger depuis la m√©moire
            return "Pr√©f√©rences: Style professionnel, notifications 9h, priorit√© haute"
        
        @sk_function(
            description="Add user interest or expertise area",
            name="add_interest"
        )
        def add_interest(interest: str) -> str:
            """Ajouter un centre d'int√©r√™t"""
            return f"Centre d'int√©r√™t ajout√©: {interest}"
        
        return {
            "update_preference": update_preference,
            "get_preferences": get_preferences,
            "add_interest": add_interest
        }
    
    def create_task_plugin(self):
        """Plugin pour gestion des t√¢ches"""
        
        @sk_function(
            description="Create a new task with priority and deadline",
            name="create_task"
        )
        def create_task(title: str, priority: str = "medium", deadline: str = "") -> str:
            """Cr√©er une nouvelle t√¢che"""
            task_id = hash(title + str(datetime.now())) % 10000
            return f"T√¢che cr√©√©e: {title} (ID: {task_id}, Priorit√©: {priority})"
        
        @sk_function(
            description="List all pending tasks",
            name="list_tasks"
        )
        def list_tasks() -> str:
            """Lister les t√¢ches en cours"""
            # En production: r√©cup√©rer depuis la m√©moire
            return "T√¢ches en cours: 1. Projet IA (haute), 2. Rapport (moyenne)"
        
        @sk_function(
            description="Mark a task as completed",
            name="complete_task"
        )
        def complete_task(task_id: str) -> str:
            """Marquer une t√¢che comme termin√©e"""
            return f"T√¢che {task_id} marqu√©e comme termin√©e"
        
        return {
            "create_task": create_task,
            "list_tasks": list_tasks,
            "complete_task": complete_task
        }
```

**Concepts Cl√©s Plugins**:
- **@sk_function**: D√©corateur pour fonctions natives
- **description**: Description pour le planner automatique
- **name**: Nom unique de la fonction
- **Type hints**: Important pour l'inf√©rence automatique

### ‚úÖ TODO 5: Initialisation du Syst√®me (10 min)

**Concepts appris**: Configuration Semantic Kernel

Impl√©mentez l'initialisation dans `__init__`:

```python
def __init__(self):
    print("üöÄ Initialisation de votre agent intelligent...")
    
    # V√©rifier la cl√© API
    api_key = os.getenv("OPENAI_API_KEY")
    if not api_key:
        raise ValueError("‚ùå OPENAI_API_KEY non trouv√©e ! Cr√©ez un fichier .env")
    
    # Cr√©er le kernel Semantic Kernel
    self.kernel = sk.Kernel()
    
    # Configurer le service AI pour chat completion
    self.kernel.add_text_completion_service(
        "gpt-4-completion",
        OpenAIChatCompletion("gpt-4", api_key, org_id=None)
    )
    
    # Configurer les embeddings pour la m√©moire
    self.kernel.add_text_embedding_generation_service(
        "text-embedding-ada-002",
        OpenAITextEmbedding("text-embedding-ada-002", api_key)
    )
    
    # Initialiser la m√©moire s√©mantique
    self.kernel.register_memory_store(SemanticTextMemory(
        storage=sk.memory.VolatileMemoryStore(),  # En production: persistant
        embeddings_generator=self.kernel.get_service("text-embedding-ada-002")
    ))
    
    # Initialiser vos variables d'instance
    self.plugins = PluginRegistry()
    self.planner = None
    self.agent_state = AgentState(
        created_at=datetime.now().isoformat(),
        conversation_count=0
    )
    self.conversation_history = []
    
    print("‚úÖ Configuration de base termin√©e")
    print("üß† Kernel initialis√© avec services AI")
    print("üíæ M√©moire s√©mantique configur√©e")
```

**Bonnes Pratiques Semantic Kernel**:
- **Services s√©par√©s**: Completion et embeddings distincts
- **Memory store**: Stockage vectoriel pour recherche s√©mantique
- **Service registration**: Enregistrement propre des services
- **Error handling**: Validation des pr√©requis

### ‚úÖ TODO 6: Plugins Personnalis√©s (15 min)

**Concepts appris**: Syst√®me de plugins Semantic Kernel

Impl√©mentez `create_custom_plugins()`:

```python
def create_custom_plugins(self):
    print("\nüîå √âTAPE: Cr√©ation de plugins personnalis√©s")
    print("=" * 60)
    
    # Cr√©er le plugin Time
    time_functions = self.plugins.create_time_plugin()
    time_plugin = self.kernel.import_plugin_from_object(
        time_functions, 
        plugin_name="TimePlugin"
    )
    
    # Cr√©er le plugin Preference
    pref_functions = self.plugins.create_preference_plugin()
    pref_plugin = self.kernel.import_plugin_from_object(
        pref_functions,
        plugin_name="PreferencePlugin"
    )
    
    # Cr√©er le plugin Task
    task_functions = self.plugins.create_task_plugin()
    task_plugin = self.kernel.import_plugin_from_object(
        task_functions,
        plugin_name="TaskPlugin"
    )
    
    # Cr√©er un plugin Weather simple (exemple)
    @sk_function(
        description="Get weather information for a location",
        name="get_weather"
    )
    def get_weather(location: str) -> str:
        """Obtenir la m√©t√©o d'un lieu"""
        # Simulation - en production: appel API m√©t√©o r√©elle
        return f"M√©t√©o √† {location}: Ensoleill√©, 22¬∞C"
    
    weather_plugin = self.kernel.import_plugin_from_object(
        {"get_weather": get_weather},
        plugin_name="WeatherPlugin"
    )
    
    # Cr√©er un plugin de calcul
    @sk_function(
        description="Perform basic mathematical calculations",
        name="calculate"
    )
    def calculate(expression: str) -> str:
        """Effectuer des calculs math√©matiques"""
        try:
            # S√©curis√©: seulement op√©rations de base
            allowed_chars = set("0123456789+-*/.() ")
            if all(c in allowed_chars for c in expression):
                result = eval(expression)
                return f"R√©sultat: {result}"
            else:
                return "Expression non autoris√©e"
        except Exception as e:
            return f"Erreur de calcul: {e}"
    
    calc_plugin = self.kernel.import_plugin_from_object(
        {"calculate": calculate},
        plugin_name="CalculatorPlugin"
    )
    
    print("‚úÖ Plugins cr√©√©s avec succ√®s:")
    print("   üïí TimePlugin - Gestion du temps et rappels")
    print("   ‚öôÔ∏è PreferencePlugin - Pr√©f√©rences utilisateur")
    print("   üìã TaskPlugin - Gestion des t√¢ches")
    print("   üå§Ô∏è WeatherPlugin - Informations m√©t√©o")
    print("   üî¢ CalculatorPlugin - Calculs math√©matiques")
    
    return True
```

**Patterns d'Plugins**:
- **Plugin grouping**: Fonctions li√©es regroup√©es
- **Naming convention**: Noms descriptifs et coh√©rents
- **Error handling**: Gestion robuste des erreurs
- **Security**: Validation des entr√©es utilisateur

### ‚úÖ TODO 7: M√©moire S√©mantique (12 min)

**Concepts appris**: M√©moire persistante et recherche s√©mantique

Impl√©mentez `setup_semantic_memory()`:

```python
async def setup_semantic_memory(self):
    print("\nüß† √âTAPE: Configuration de la m√©moire s√©mantique")
    print("=" * 60)
    
    # Cr√©er les collections de m√©moire
    memory_collections = [
        "conversations",    # Historique des conversations
        "preferences",      # Pr√©f√©rences utilisateur
        "knowledge",        # Base de connaissances personnelle
        "tasks",           # Historique des t√¢ches
        "context"          # Contexte de travail
    ]
    
    # Initialiser les collections
    for collection in memory_collections:
        try:
            await self.kernel.memory.create_collection_async(collection)
            print(f"   ‚úÖ Collection '{collection}' cr√©√©e")
        except Exception as e:
            print(f"   ‚ÑπÔ∏è Collection '{collection}' existe d√©j√†")
    
    # Charger la m√©moire existante depuis le fichier
    await self._load_persistent_memory()
    
    # Ajouter des connaissances de base
    await self._seed_initial_knowledge()
    
    print("üß† M√©moire s√©mantique configur√©e avec succ√®s")
    return True

async def _load_persistent_memory(self):
    """Charger la m√©moire persistante depuis le fichier"""
    memory_file = Path("memory_state.json")
    
    if memory_file.exists():
        try:
            with open(memory_file, "r", encoding="utf-8") as f:
                memory_data = json.load(f)
            
            # Restaurer les pr√©f√©rences
            agent_info = memory_data.get("agent_info", {})
            self.agent_state.last_interaction = agent_info.get("last_interaction")
            self.agent_state.conversation_count = agent_info.get("total_conversations", 0)
            
            print("   üìÇ M√©moire persistante charg√©e")
            
        except Exception as e:
            print(f"   ‚ö†Ô∏è Erreur lors du chargement de la m√©moire: {e}")
    else:
        print("   üÜï Premi√®re utilisation - nouvelle m√©moire cr√©√©e")

async def _seed_initial_knowledge(self):
    """Ajouter des connaissances de base"""
    initial_knowledge = [
        {
            "collection": "knowledge",
            "text": "Semantic Kernel est un framework Microsoft pour cr√©er des agents IA avec planification automatique et m√©moire.",
            "id": "sk_intro"
        },
        {
            "collection": "knowledge", 
            "text": "Les plugins Semantic Kernel permettent d'√©tendre les capacit√©s de l'agent avec des fonctions personnalis√©es.",
            "id": "sk_plugins"
        },
        {
            "collection": "knowledge",
            "text": "La planification automatique permet de d√©composer des t√¢ches complexes en √©tapes simples.",
            "id": "sk_planning"
        }
    ]
    
    for item in initial_knowledge:
        try:
            await self.kernel.memory.save_information_async(
                collection=item["collection"],
                text=item["text"],
                id=item["id"]
            )
        except Exception:
            pass  # D√©j√† existant
    
    print("   üìö Connaissances de base ajout√©es")
```

**Concepts M√©moire S√©mantique**:
- **Collections**: Organisation th√©matique des souvenirs
- **Embeddings**: Vectorisation pour recherche s√©mantique
- **Persistence**: Sauvegarde entre sessions
- **Seeding**: Connaissances de base initiales

### ‚úÖ TODO 8: Planificateur Automatique (10 min)

**Concepts appris**: Planification et orchestration automatique

Impl√©mentez `create_automatic_planner()`:

```python
def create_automatic_planner(self):
    print("\nüìã √âTAPE: Cr√©ation du planificateur automatique")
    print("=" * 60)
    
    # Cr√©er le planner avec configuration optimis√©e
    self.planner = BasicPlanner()
    
    # Configuration des capacit√©s de planification
    self.planning_config = {
        "max_tokens": 1000,
        "temperature": 0.3,  # Plus d√©terministe pour planification
        "max_iterations": 5,
        "allow_missing_functions": False,
        "excluded_plugins": [],  # Plugins √† exclure si n√©cessaire
        "included_functions": []  # Fonctions sp√©cifiques √† inclure
    }
    
    # Cr√©er des exemples de plans pour diff√©rents sc√©narios
    self.example_plans = {
        "productivity": {
            "description": "Plan a productive day based on user preferences",
            "expected_functions": ["TimePlugin.get_current_time", "TaskPlugin.list_tasks", "PreferencePlugin.get_preferences"]
        },
        "learning": {
            "description": "Help me learn about AI agents step by step",
            "expected_functions": ["memory search", "structured explanation", "progress tracking"]
        },
        "organization": {
            "description": "Organize my project timeline with reminders",
            "expected_functions": ["TaskPlugin.create_task", "TimePlugin.schedule_reminder", "task prioritization"]
        },
        "analysis": {
            "description": "Analyze data and provide insights with recommendations",
            "expected_functions": ["data processing", "pattern recognition", "recommendation generation"]
        }
    }
    
    print("‚úÖ Planificateur automatique configur√©")
    print("üéØ Capacit√©s de planification:")
    print("   ‚Ä¢ D√©composition automatique de t√¢ches complexes")
    print("   ‚Ä¢ S√©lection intelligente de plugins")
    print("   ‚Ä¢ Orchestration multi-√©tapes")
    print("   ‚Ä¢ Adaptation en cas d'erreur")
    
    return True

async def _demonstrate_planning_capability(self, goal: str):
    """D√©montrer les capacit√©s de planification"""
    try:
        print(f"\nüéØ D√©monstration de planification pour: {goal}")
        
        # Cr√©er un plan pour l'objectif donn√©
        plan = await self.planner.create_plan_async(goal, self.kernel)
        
        print("üìã Plan g√©n√©r√©:")
        for i, step in enumerate(plan.steps, 1):
            print(f"   {i}. {step.description}")
            print(f"      Plugin: {step.plugin_name}")
            print(f"      Fonction: {step.function_name}")
        
        return plan
        
    except Exception as e:
        print(f"‚ùå Erreur lors de la planification: {e}")
        return None
```

**Capacit√©s du Planner**:
- **Auto-decomposition**: Division automatique des t√¢ches
- **Function selection**: Choix optimal des plugins
- **Error recovery**: Adaptation en cas de probl√®me
- **Goal orientation**: Focus sur l'objectif final

### ‚úÖ TODO 9: Conversation avec M√©moire (20 min)

**Concepts appris**: Int√©gration m√©moire et conversation

Impl√©mentez `implement_conversation_with_memory()`:

```python
async def implement_conversation_with_memory(self, user_input: str):
    print(f"\nüí¨ √âTAPE: Conversation avec m√©moire - '{user_input}'")
    print("=" * 60)
    
    start_time = datetime.now()
    
    try:
        # 1. Rechercher le contexte dans la m√©moire s√©mantique
        relevant_memories = await self._search_relevant_context(user_input)
        
        # 2. Analyser la complexit√© et d√©cider du traitement
        complexity_analysis = self._analyze_query_complexity(user_input)
        needs_planning = complexity_analysis["requires_planning"]
        
        print(f"üîç Contexte trouv√©: {len(relevant_memories)} √©l√©ments")
        print(f"üìä Complexit√©: {complexity_analysis['score']:.2f} - Planning: {'Oui' if needs_planning else 'Non'}")
        
        # 3. Construire le prompt avec contexte et personnalisation
        context_prompt = await self._build_context_prompt(user_input, relevant_memories)
        
        # 4. Traitement selon la complexit√©
        if needs_planning:
            print("üéØ Utilisation du planificateur pour t√¢che complexe")
            response = await self._handle_complex_query_with_planning(user_input, context_prompt)
        else:
            print("üí¨ R√©ponse directe avec contexte")
            response = await self._handle_simple_query(user_input, context_prompt)
        
        execution_time = (datetime.now() - start_time).total_seconds()
        
        # 5. M√©moriser la conversation
        await self._memorize_conversation(user_input, response, execution_time)
        
        # 6. Mettre √† jour l'√©tat de l'agent
        self._update_agent_state(user_input, response)
        
        print(f"‚úÖ Conversation trait√©e en {execution_time:.2f}s")
        
        return {
            "user_input": user_input,
            "response": response,
            "execution_time": execution_time,
            "used_memory": len(relevant_memories) > 0,
            "used_planning": needs_planning,
            "context_elements": len(relevant_memories),
            "complexity_score": complexity_analysis["score"],
            "timestamp": start_time.isoformat()
        }
        
    except Exception as e:
        print(f"‚ùå Erreur durant la conversation: {e}")
        return {
            "user_input": user_input,
            "response": f"D√©sol√©, j'ai rencontr√© une erreur: {e}",
            "error": str(e),
            "execution_time": (datetime.now() - start_time).total_seconds(),
            "timestamp": start_time.isoformat()
        }

async def _search_relevant_context(self, query: str, limit: int = 3):
    """Rechercher le contexte pertinent dans la m√©moire"""
    try:
        # Recherche dans toutes les collections
        all_memories = []
        
        for collection in ["conversations", "knowledge", "preferences"]:
            memories = await self.kernel.memory.search_async(
                collection=collection,
                query=query,
                limit=limit
            )
            all_memories.extend(memories)
        
        # Trier par pertinence et retourner les meilleurs
        sorted_memories = sorted(all_memories, key=lambda x: x.relevance, reverse=True)
        return sorted_memories[:limit]
        
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur recherche m√©moire: {e}")
        return []

def _analyze_query_complexity(self, query: str) -> Dict[str, Any]:
    """Analyser la complexit√© d'une requ√™te"""
    complexity_indicators = {
        "multi_step_keywords": ["plan", "organize", "schedule", "analyze", "compare", "strategy"],
        "question_complexity": ["how to", "what if", "explain", "breakdown", "step by step"],
        "time_planning": ["tomorrow", "next week", "schedule", "remind", "deadline"],
        "multi_domain": ["and", "also", "plus", "additionally"],
        "conditional": ["if", "when", "unless", "depending"]
    }
    
    score = 0
    detected_indicators = []
    
    query_lower = query.lower()
    
    for category, keywords in complexity_indicators.items():
        for keyword in keywords:
            if keyword in query_lower:
                score += 1
                detected_indicators.append(f"{category}:{keyword}")
    
    # Normaliser le score
    max_possible = sum(len(keywords) for keywords in complexity_indicators.values())
    normalized_score = score / max_possible if max_possible > 0 else 0
    
    return {
        "score": normalized_score,
        "requires_planning": normalized_score > 0.3,  # Seuil de complexit√©
        "indicators": detected_indicators,
        "category": "complex" if normalized_score > 0.3 else "simple"
    }

async def _build_context_prompt(self, user_input: str, memories: List) -> str:
    """Construire un prompt avec contexte personnalis√©"""
    context_parts = []
    
    # Ajouter les souvenirs pertinents
    if memories:
        context_parts.append("Contexte m√©moris√©:")
        for memory in memories:
            context_parts.append(f"- {memory.text}")
    
    # Ajouter les pr√©f√©rences utilisateur
    prefs = f"""Pr√©f√©rences utilisateur:
- Style de communication: {self.agent_state.communication_style}
- Langue: {self.agent_state.language}
- Contexte: {self.agent_state.work_context or 'Non sp√©cifi√©'}
- Int√©r√™ts: {', '.join(self.agent_state.interests) if self.agent_state.interests else 'Non sp√©cifi√©s'}"""
    
    context_parts.append(prefs)
    
    # Construire le prompt final
    context_section = "\n".join(context_parts)
    
    prompt = f"""Tu es un assistant intelligent personnel avec acc√®s √† la m√©moire et aux pr√©f√©rences de l'utilisateur.

{context_section}

Instructions:
- Utilise le contexte m√©moris√© pour personnaliser ta r√©ponse
- Respecte le style de communication pr√©f√©r√©
- Sois proactif en sugg√©rant des actions pertinentes
- Si des informations sont manquantes, demande des clarifications

Requ√™te utilisateur: {user_input}

R√©ponse personnalis√©e:"""
    
    return prompt

async def _handle_simple_query(self, user_input: str, context_prompt: str) -> str:
    """Traiter une requ√™te simple avec contexte"""
    try:
        # Cr√©er une fonction s√©mantique pour la r√©ponse
        response_function = self.kernel.create_semantic_function(
            prompt_template=context_prompt,
            max_tokens=500,
            temperature=0.7
        )
        
        # Ex√©cuter la fonction
        result = await response_function.invoke_async()
        return result.result.strip()
        
    except Exception as e:
        return f"Erreur lors du traitement: {e}"

async def _handle_complex_query_with_planning(self, user_input: str, context_prompt: str) -> str:
    """Traiter une requ√™te complexe avec planification"""
    try:
        # Cr√©er un plan pour la requ√™te complexe
        plan = await self.planner.create_plan_async(user_input, self.kernel)
        
        # Ex√©cuter le plan
        plan_result = await plan.invoke_async()
        
        # Enrichir avec le contexte
        enriched_prompt = f"""{context_prompt}

Plan ex√©cut√©: {plan_result.result}

Synth√®se finale personnalis√©e:"""
        
        # G√©n√©rer la r√©ponse finale
        synthesis_function = self.kernel.create_semantic_function(
            prompt_template=enriched_prompt,
            max_tokens=600,
            temperature=0.6
        )
        
        final_result = await synthesis_function.invoke_async()
        return final_result.result.strip()
        
    except Exception as e:
        return f"Erreur lors de la planification: {e}"

async def _memorize_conversation(self, user_input: str, response: str, execution_time: float):
    """M√©moriser la conversation dans la m√©moire s√©mantique"""
    try:
        conversation_text = f"Utilisateur: {user_input}\nAssistant: {response}"
        conversation_id = f"conv_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        await self.kernel.memory.save_information_async(
            collection="conversations",
            text=conversation_text,
            id=conversation_id,
            description=f"Conversation du {datetime.now().strftime('%Y-%m-%d %H:%M')}"
        )
        
        print(f"üíæ Conversation m√©moris√©e (ID: {conversation_id})")
        
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur m√©morisation: {e}")

def _update_agent_state(self, user_input: str, response: str):
    """Mettre √† jour l'√©tat de l'agent"""
    self.agent_state.last_interaction = datetime.now().isoformat()
    self.agent_state.conversation_count += 1
    
    # Ajouter √† l'historique local
    self.conversation_history.append({
        "user": user_input,
        "assistant": response,
        "timestamp": datetime.now().isoformat(),
        "turn": self.agent_state.conversation_count
    })
    
    # Analyser pour d√©tecter de nouveaux int√©r√™ts
    self._detect_user_interests(user_input)

def _detect_user_interests(self, user_input: str):
    """D√©tecter de nouveaux centres d'int√©r√™t"""
    tech_keywords = ["IA", "machine learning", "python", "data", "cloud", "blockchain"]
    business_keywords = ["strat√©gie", "marketing", "finance", "management", "startup"]
    
    user_lower = user_input.lower()
    
    for keyword in tech_keywords:
        if keyword.lower() in user_lower and "technologie" not in self.agent_state.interests:
            self.agent_state.interests.append("technologie")
            print(f"üéØ Nouvel int√©r√™t d√©tect√©: technologie")
            break
    
    for keyword in business_keywords:
        if keyword.lower() in user_lower and "business" not in self.agent_state.interests:
            self.agent_state.interests.append("business")
            print(f"üéØ Nouvel int√©r√™t d√©tect√©: business")
            break
```

### ‚úÖ TODO 10: Gestion des Pr√©f√©rences (8 min)

**Concepts appris**: Personnalisation et adaptation

Impl√©mentez `manage_user_preferences()`:

```python
async def manage_user_preferences(self, preference_type: str, value: Any):
    print(f"\n‚öôÔ∏è √âTAPE: Gestion des pr√©f√©rences - {preference_type}")
    print("=" * 60)
    
    # Valider le type de pr√©f√©rence
    valid_preferences = {
        "communication_style": ["professional", "casual", "formal"],
        "notification_time": "time_format",  # HH:MM
        "task_priority": ["high", "medium", "low"],
        "language": ["fr", "en", "es", "de"],
        "timezone": "timezone_format",
        "work_context": "free_text"
    }
    
    if preference_type not in valid_preferences:
        print(f"‚ùå Type de pr√©f√©rence invalide: {preference_type}")
        print(f"   Types valides: {', '.join(valid_preferences.keys())}")
        return False
    
    # Valider la valeur selon le type
    validation_result = self._validate_preference_value(preference_type, value, valid_preferences)
    
    if not validation_result["valid"]:
        print(f"‚ùå Valeur invalide: {validation_result['reason']}")
        return False
    
    # Mettre √† jour l'√©tat local
    old_value = getattr(self.agent_state, preference_type, "Non d√©fini")
    setattr(self.agent_state, preference_type, value)
    
    # Sauvegarder dans la m√©moire s√©mantique
    await self._save_preference_to_memory(preference_type, value, old_value)
    
    print(f"‚úÖ Pr√©f√©rence mise √† jour:")
    print(f"   {preference_type}: {old_value} ‚Üí {value}")
    
    return True

def _validate_preference_value(self, pref_type: str, value: Any, valid_prefs: Dict) -> Dict:
    """Valider une valeur de pr√©f√©rence"""
    constraints = valid_prefs[pref_type]
    
    if isinstance(constraints, list):
        # Valeurs pr√©d√©finies
        if value in constraints:
            return {"valid": True}
        else:
            return {"valid": False, "reason": f"Valeurs accept√©es: {', '.join(constraints)}"}
    
    elif constraints == "time_format":
        # Format HH:MM
        try:
            datetime.strptime(value, "%H:%M")
            return {"valid": True}
        except ValueError:
            return {"valid": False, "reason": "Format attendu: HH:MM (ex: 09:30)"}
    
    elif constraints == "timezone_format":
        # Validation basique de timezone
        valid_timezones = ["Europe/Paris", "America/New_York", "Asia/Tokyo", "UTC"]
        if value in valid_timezones:
            return {"valid": True}
        else:
            return {"valid": False, "reason": f"Timezones support√©es: {', '.join(valid_timezones)}"}
    
    elif constraints == "free_text":
        # Texte libre avec contraintes basiques
        if isinstance(value, str) and 3 <= len(value) <= 200:
            return {"valid": True}
        else:
            return {"valid": False, "reason": "Texte entre 3 et 200 caract√®res"}
    
    return {"valid": False, "reason": "Type de contrainte non reconnu"}

async def _save_preference_to_memory(self, pref_type: str, value: Any, old_value: Any):
    """Sauvegarder une pr√©f√©rence dans la m√©moire"""
    try:
        pref_text = f"Pr√©f√©rence {pref_type}: {value} (ancienne valeur: {old_value})"
        pref_id = f"pref_{pref_type}_{datetime.now().strftime('%Y%m%d')}"
        
        await self.kernel.memory.save_information_async(
            collection="preferences",
            text=pref_text,
            id=pref_id,
            description=f"Mise √† jour pr√©f√©rence {pref_type}"
        )
        
        print(f"üíæ Pr√©f√©rence sauvegard√©e en m√©moire")
        
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur sauvegarde pr√©f√©rence: {e}")
```

### ‚úÖ TODO 11: D√©monstration Planification (10 min)

**Concepts appris**: Planification complexe et adaptation

Impl√©mentez `demonstrate_planning_capabilities()`:

```python
async def demonstrate_planning_capabilities(self):
    print("\nüéØ √âTAPE: D√©monstration des capacit√©s de planification")
    print("=" * 60)
    
    demo_scenarios = [
        "Plan me a productive day based on my preferences",
        "Help me organize a project to learn machine learning in 3 months",
        "Create a strategy to improve my work-life balance with specific actions",
        "Plan a comprehensive research approach for AI agent frameworks"
    ]
    
    print("üìã Sc√©narios de planification:")
    for i, scenario in enumerate(demo_scenarios, 1):
        print(f"  {i}. {scenario}")
    
    # Ex√©cuter les sc√©narios de planification
    for i, scenario in enumerate(demo_scenarios, 1):
        print(f"\nüéØ Sc√©nario {i}: {scenario}")
        print("-" * 50)
        
        try:
            # Cr√©er et ex√©cuter le plan
            plan = await self.planner.create_plan_async(scenario, self.kernel)
            
            print(f"üìù Plan g√©n√©r√© ({len(plan.steps)} √©tapes):")
            for j, step in enumerate(plan.steps, 1):
                print(f"   {j}. {step.description}")
                if hasattr(step, 'plugin_name') and step.plugin_name:
                    print(f"      ‚Üí Plugin: {step.plugin_name}.{step.function_name}")
            
            # Simuler l'ex√©cution (en production: vraie ex√©cution)
            print(f"‚ö° Simulation d'ex√©cution...")
            execution_time = len(plan.steps) * 0.5  # Simulation
            
            print(f"‚úÖ Plan ex√©cut√© en {execution_time:.1f}s (simul√©)")
            
            # D√©montrer l'adaptation d'erreur
            if i == 2:  # Pour le sc√©nario work-life balance
                print("üîÑ D√©monstration d'adaptation d'erreur:")
                print("   ‚Ä¢ Erreur simul√©e: Plugin indisponible")
                print("   ‚Ä¢ Adaptation: Utilisation d'alternative")
                print("   ‚Ä¢ R√©cup√©ration: Plan modifi√© automatiquement")
            
        except Exception as e:
            print(f"‚ùå Erreur planification: {e}")
            print("üîÑ En production: retry avec plan simplifi√©")
        
        if i < len(demo_scenarios):
            print()
    
    print(f"\nüèÜ D√©monstration de planification termin√©e")
    print("üí° Capacit√©s d√©montr√©es:")
    print("   ‚Ä¢ D√©composition automatique de t√¢ches complexes")
    print("   ‚Ä¢ S√©lection intelligente de plugins")
    print("   ‚Ä¢ Adaptation en cas de probl√®me")
    print("   ‚Ä¢ Personnalisation selon le contexte utilisateur")
```

### ‚úÖ TODO 12: Sauvegarde d'√âtat (5 min)

**Concepts appris**: Persistance et continuit√©

Impl√©mentez `save_agent_state()`:

```python
def save_agent_state(self):
    print("\nüíæ √âTAPE: Sauvegarde de l'√©tat de l'agent")
    print("=" * 60)
    
    # Pr√©parer les donn√©es d'√©tat
    state_data = {
        "agent_info": {
            "created_at": self.agent_state.created_at,
            "last_interaction": self.agent_state.last_interaction,
            "total_conversations": self.agent_state.conversation_count,
            "version": "1.0.0",
            "last_saved": datetime.now().isoformat()
        },
        "user_preferences": {
            "communication_style": self.agent_state.communication_style,
            "notification_time": self.agent_state.notification_time,
            "task_priority": self.agent_state.task_priority,
            "language": self.agent_state.language,
            "timezone": self.agent_state.timezone,
            "work_context": self.agent_state.work_context
        },
        "user_profile": {
            "interests": self.agent_state.interests,
            "learning_preferences": self.agent_state.learning_preferences,
            "conversation_count": self.agent_state.conversation_count
        },
        "conversation_summary": {
            "recent_topics": self._extract_recent_topics(),
            "user_interaction_patterns": self._analyze_interaction_patterns(),
            "recurring_requests": self._identify_recurring_requests()
        },
        "performance_metrics": {
            "avg_response_time": self._calculate_avg_response_time(),
            "successful_plans": self._count_successful_plans(),
            "memory_utilization": self._estimate_memory_usage(),
            "plugin_usage_stats": self._get_plugin_usage_stats()
        },
        "system_health": {
            "memory_collections_count": 5,  # conversations, preferences, knowledge, tasks, context
            "plugins_active": 5,  # Time, Preference, Task, Weather, Calculator
            "last_error": None,
            "uptime_sessions": self.agent_state.conversation_count
        }
    }
    
    # Sauvegarder dans memory_state.json
    try:
        with open("memory_state.json", "w", encoding="utf-8") as f:
            json.dump(state_data, f, indent=2, ensure_ascii=False)
        
        print("‚úÖ √âtat de l'agent sauvegard√© dans memory_state.json")
        print(f"üìä R√©sum√© de session:")
        print(f"   ‚Ä¢ Conversations: {state_data['agent_info']['total_conversations']}")
        print(f"   ‚Ä¢ Int√©r√™ts d√©tect√©s: {len(self.agent_state.interests)}")
        print(f"   ‚Ä¢ Plugins actifs: {state_data['system_health']['plugins_active']}")
        
    except Exception as e:
        print(f"‚ùå Erreur sauvegarde: {e}")

def _extract_recent_topics(self) -> List[str]:
    """Extraire les sujets r√©cents des conversations"""
    topics = []
    for conv in self.conversation_history[-5:]:  # 5 derni√®res conversations
        user_msg = conv["user"].lower()
        if "plan" in user_msg or "organiz" in user_msg:
            topics.append("planification")
        elif "learn" in user_msg or "explain" in user_msg:
            topics.append("apprentissage")
        elif "prefer" in user_msg or "setting" in user_msg:
            topics.append("configuration")
    return list(set(topics))

def _analyze_interaction_patterns(self) -> Dict[str, Any]:
    """Analyser les patterns d'interaction"""
    if not self.conversation_history:
        return {"pattern": "insufficient_data"}
    
    # Analyser la longueur des questions
    avg_question_length = sum(len(conv["user"].split()) for conv in self.conversation_history) / len(self.conversation_history)
    
    # Analyser la fr√©quence
    time_intervals = []
    for i in range(1, len(self.conversation_history)):
        prev_time = datetime.fromisoformat(self.conversation_history[i-1]["timestamp"])
        curr_time = datetime.fromisoformat(self.conversation_history[i]["timestamp"])
        interval = (curr_time - prev_time).total_seconds()
        time_intervals.append(interval)
    
    avg_interval = sum(time_intervals) / len(time_intervals) if time_intervals else 0
    
    return {
        "avg_question_length": avg_question_length,
        "avg_time_between_queries": f"{avg_interval:.1f}s",
        "interaction_style": "detailed" if avg_question_length > 10 else "concise"
    }

def _identify_recurring_requests(self) -> List[str]:
    """Identifier les demandes r√©currentes"""
    # Analyser les mots-cl√©s fr√©quents
    all_words = []
    for conv in self.conversation_history:
        words = conv["user"].lower().split()
        all_words.extend(word for word in words if len(word) > 3)
    
    from collections import Counter
    word_counts = Counter(all_words)
    recurring = [word for word, count in word_counts.items() if count >= 2]
    
    return recurring[:5]  # Top 5

def _calculate_avg_response_time(self) -> float:
    """Calculer le temps de r√©ponse moyen"""
    # Simulation - en production: vraies m√©triques
    return 2.3  # secondes

def _count_successful_plans(self) -> int:
    """Compter les plans r√©ussis"""
    # Simulation - en production: tracking r√©el
    return max(0, self.agent_state.conversation_count - 2)

def _estimate_memory_usage(self) -> str:
    """Estimer l'utilisation m√©moire"""
    conversations = len(self.conversation_history)
    estimated_mb = conversations * 0.1  # Estimation: 0.1MB par conversation
    return f"{estimated_mb:.1f}MB"

def _get_plugin_usage_stats(self) -> Dict[str, int]:
    """Obtenir les statistiques d'utilisation des plugins"""
    # Simulation - en production: tracking r√©el
    return {
        "TimePlugin": 3,
        "PreferencePlugin": 2,
        "TaskPlugin": 1,
        "WeatherPlugin": 1,
        "CalculatorPlugin": 0
    }
```

### ‚úÖ TODO 13: D√©monstration Compl√®te (5 min)

**Concepts appris**: Test end-to-end du syst√®me

Impl√©mentez `run_demo()`:

```python
async def run_demo(self):
    print("\nüé¨ D√âMONSTRATION DE VOTRE AGENT INTELLIGENT")
    print("=" * 60)
    
    # Interactions de d√©monstration progressives
    demo_interactions = [
        "Hello! I'm new here. Can you introduce yourself?",
        "I prefer a casual communication style",
        "What's the weather like in Paris today?",
        "Help me plan a productive morning routine with reminders",
        "Remember that I'm interested in AI and machine learning",
        "Calculate 15 * 8 + 42",
        "Plan a strategy to learn Python programming in 2 months"
    ]
    
    print("üí¨ Interactions de d√©monstration:")
    for i, interaction in enumerate(demo_interactions, 1):
        print(f"  {i}. {interaction}")
    
    print("\nüìã Processus de d√©monstration:")
    print("  1. üîå Cr√©ation des plugins personnalis√©s")
    print("  2. üß† Configuration de la m√©moire s√©mantique")
    print("  3. üìã Cr√©ation du planificateur automatique")
    print("  4. üí¨ Conversations avec m√©moire et adaptation")
    print("  5. ‚öôÔ∏è Gestion des pr√©f√©rences utilisateur")
    print("  6. üéØ D√©monstration de planification avanc√©e")
    print("  7. üíæ Sauvegarde de l'√©tat complet")
    
    # Ex√©cuter la d√©monstration compl√®te
    print("\n‚ö° Lancement de la d√©monstration...")
    
    try:
        # √âtape 1: Plugins
        if self.create_custom_plugins():
            print("‚úÖ Plugins cr√©√©s avec succ√®s")
            
            # √âtape 2: M√©moire
            if await self.setup_semantic_memory():
                print("‚úÖ M√©moire s√©mantique configur√©e")
                
                # √âtape 3: Planner
                if self.create_automatic_planner():
                    print("‚úÖ Planificateur automatique cr√©√©")
                    
                    # √âtape 4: Conversations interactives
                    print(f"\nüí¨ Ex√©cution de {len(demo_interactions)} interactions...")
                    
                    for i, interaction in enumerate(demo_interactions, 1):
                        print(f"\n--- Interaction {i}/{len(demo_interactions)} ---")
                        print(f"üë§ Utilisateur: {interaction}")
                        
                        # Traiter avec gestion sp√©ciale pour les pr√©f√©rences
                        if "prefer" in interaction.lower() and "casual" in interaction.lower():
                            await self.manage_user_preferences("communication_style", "casual")
                            response_data = {"response": "Parfait ! J'ai mis √† jour votre style de communication en mode d√©contract√©. üòä"}
                        else:
                            response_data = await self.implement_conversation_with_memory(interaction)
                        
                        print(f"ü§ñ Assistant: {response_data['response']}")
                        
                        if response_data.get("used_planning"):
                            print("   üéØ Planification automatique utilis√©e")
                        if response_data.get("used_memory"):
                            print(f"   üß† Contexte m√©moire: {response_data.get('context_elements', 0)} √©l√©ments")
                        
                        # Petite pause pour la d√©mo
                        await asyncio.sleep(0.5)
                    
                    # √âtape 5: D√©monstration planification
                    print(f"\nüéØ D√©monstration des capacit√©s de planification...")
                    await self.demonstrate_planning_capabilities()
                    
                    # √âtape 6: Sauvegarde
                    self.save_agent_state()
                    
                    print("\nüèÜ D√âMONSTRATION TERMIN√âE AVEC SUCC√àS!")
                    print("\nüìÅ Fichiers g√©n√©r√©s:")
                    print("  üíæ memory_state.json - √âtat complet de l'agent")
                    print("  üß† M√©moire s√©mantique - Collections en m√©moire")
                    print("  üìä M√©triques de performance - Int√©gr√©es dans l'√©tat")
                    
                    # Afficher les statistiques finales
                    print(f"\nüìä Statistiques de la session:")
                    print(f"   üí¨ Conversations: {self.agent_state.conversation_count}")
                    print(f"   üéØ Int√©r√™ts d√©tect√©s: {len(self.agent_state.interests)}")
                    print(f"   üîå Plugins actifs: 5 (Time, Preference, Task, Weather, Calculator)")
                    print(f"   üß† Collections m√©moire: 5 (conversations, preferences, knowledge, tasks, context)")
                    print(f"   ‚öôÔ∏è Pr√©f√©rences configur√©es: Style {self.agent_state.communication_style}")
                    
                    return True
                else:
                    print("‚ùå √âchec de la cr√©ation du planificateur")
            else:
                print("‚ùå √âchec de la configuration m√©moire")
        else:
            print("‚ùå √âchec de la cr√©ation des plugins")
            
    except Exception as e:
        print(f"‚ùå Erreur durant la d√©monstration: {e}")
        
    return False
```

## üéØ R√©sultat Final

Apr√®s avoir compl√©t√© tous les TODOs, vous aurez cr√©√© :

### üìÅ Fichiers G√©n√©r√©s
- ‚úÖ `memory_state.json` - √âtat complet de l'agent avec pr√©f√©rences et m√©triques
- ‚úÖ Collections m√©moire - Stockage s√©mantique des conversations et connaissances
- ‚úÖ Plugins personnalis√©s - 5 plugins fonctionnels (Time, Preference, Task, Weather, Calculator)

### üéì Comp√©tences Acquises
- **Semantic Kernel**: Kernel, plugins, fonctions s√©mantiques
- **Planification**: D√©composition automatique et orchestration
- **M√©moire**: Stockage s√©mantique et recherche contextuelle
- **Personnalisation**: Pr√©f√©rences utilisateur et adaptation
- **Production**: √âtat persistant et m√©triques de performance

### üöÄ Applications Possibles
- Assistant personnel intelligent
- Agent de productivit√© avec m√©moire
- Syst√®me de recommandations adaptatif
- Chatbot d'entreprise avec contexte

## üé¨ D√©monstration

Lancez votre agent termin√© :

```bash
python my_intelligent_agent_starter.py
```

Le syst√®me ex√©cutera automatiquement :
1. ‚úÖ Cr√©ation de 5 plugins personnalis√©s
2. ‚úÖ Configuration m√©moire s√©mantique avec 5 collections
3. ‚úÖ Planificateur automatique avec d√©composition de t√¢ches
4. ‚úÖ 7 conversations interactives avec adaptation
5. ‚úÖ D√©monstration de planification complexe
6. ‚úÖ Sauvegarde d'√©tat complet avec m√©triques

## üîß Personnalisation

### Adapter √† Votre Domaine
1. **Plugins**: Cr√©ez des fonctions sp√©cifiques √† votre m√©tier
2. **M√©moire**: Ajoutez des collections pour vos donn√©es
3. **Pr√©f√©rences**: √âtendez les types selon vos besoins
4. **Planification**: Adaptez les patterns de d√©composition

### Optimisations Production
1. **Performance**: M√©moire vectorielle distribu√©e, caching intelligent
2. **Scalabilit√©**: Multi-utilisateurs, isolation des donn√©es
3. **Int√©grations**: APIs externes, webhooks, notifications
4. **S√©curit√©**: Chiffrement, audit logs, permissions

## üèÜ Validation des Acquis

Vous ma√Ætrisez le projet si vous pouvez :
- [ ] Expliquer l'architecture Semantic Kernel (Kernel, Plugins, Planner, Memory)
- [ ] Cr√©er des plugins personnalis√©s avec @sk_function
- [ ] Configurer la m√©moire s√©mantique et recherche contextuelle
- [ ] Utiliser la planification automatique pour t√¢ches complexes
- [ ] Impl√©menter la persistance d'√©tat et personnalisation

## üîó Ressources pour Aller Plus Loin

- [Semantic Kernel Documentation](https://learn.microsoft.com/en-us/semantic-kernel/)
- [Plugin Development Guide](https://learn.microsoft.com/en-us/semantic-kernel/agents/plugins/)
- [Planning and Orchestration](https://learn.microsoft.com/en-us/semantic-kernel/agents/planning/)
- [Memory and Embeddings](https://learn.microsoft.com/en-us/semantic-kernel/memories/)

---

üéØ **F√©licitations !** Vous avez construit un agent intelligent adaptatif et ma√Ætris√© Semantic Kernel !